## 概述：

### 项目架构：三级依赖

![img](/Users/meteor/Pictures/image2018-10-8 17_26_42.png)

> 如图所示，项目分为八大公共库。内含项目运作所需的公共方法/资源/样式/对第三方依赖的处理/Webpack配置。
>
> 公共页面库里面存储了整个APP内都需要用到的`通用`页面，本质上跟模块是一样的，只不过称呼不一样。而每个模块都像是一个微型总库，只不过产物和总库不一样。
>
> 总库经过Webpack构建库产出的是一个完整的，含html、js、css的前端项目。而各公共库、模块库产出的仅为经过Webpack构件库处理后压缩混淆的js、css代码，或直接被总库所用，或被路由库引用后再被总库所用。

#### 工作原理：

**代码仓库：**Gogs

**私有Npm库：**Verdaccio

**自动构建：**Drone

**流程：**每个开发者都会有自己的一个`所有平台共享`的账号，开发者仅需将代码推向Gogs中，由DevOps工程师部署的脚本对推上的内容进行简单校验并对版本号进行修改(该步骤是经过各方沟通后决定)确认无误后，由CI账户（开发者无权限）推送至Verdaccio，在公司的私有Drone页面可以看到推送过程。

这样开发者就可以用npm工具来管理自己所发布的package（这个package的意思就是将开发者的代码进行压缩混淆后的产物，在Verdaccio上存储。如果A开发者没有B开发者Gogs仓库的权限，那么这是A开发者看到B开发者代码的唯一方式。）

#### 架构优点：

权限控制优秀，源码保密性强。

在严格的权限管理下，开发者仅需简单的推送代码即可完成功能的迭代，每个开发者负责的模块交集少，从模块的角度上来说，代码污染情况很少发生。

#### 架构缺点：

①公共库之间代码污染明显，如果不是公共库管理者，对于其中的行为及变量传递必然不是很清楚。

> 比如说对于工具库而言，内含各种公共方法/第三方依赖修改，不可避免的会操作到全局变量库的内容。此时就会需要在工具库各文件内都引入store变量。

②调试困难。

> 一般的项目架构是走分支合并的路线，在一个文件夹内开发。各种变量及依赖关系一目了然，搜索方便。功能验证仅需开启DevServer即可看到结果，无需做二次三次Check。
>
> 而在三级依赖架构中，我们每次推送代码，首先自己的模块内会启动DevServer进行校验一次，然后推送至Verdaccio后需要在总库Upgrade package后再校验一次。其中会浪费一定的时间。
>
> 而且如果我们看到，A/B/C三个库可能都依赖一个公共方法，我们对这个公共方法进行了修改，那么可能需要先推送公共方法至Gogs库走流程，等构建完毕再轮流到A/B/C三个库去验证我们代码的可靠性。
>
> 目前项目还是没有一个供开发者使用的Dev环境，开发者做了什么改动/尝试，都会一步到位的到预生产环境，这就会让测试非常迷惑：为什么之前出现的一个问题现在又频繁复现，到底是开发者最终的代码问题还是他们在修改功能中引发的问题？

③Webpack配置繁琐，依赖引入麻烦。

> 就说Vue-router官方允许我们使用懒加载的方式异步加载路由，这样可以让单页应用不再臃肿。
>
> 但是如果按照项目的三级依赖来说，我们首先在应用异步加载上面就出现了困难，因为我们不是直接在目录中引入一个.vue文件那么简单，我们面对的是一个经过Webpack处理的index.js大文件。
>
> 对于初步接触框架的开发者来说这无疑是个很让人困惑的事情->为什么我按照官方给的例子自行尝试的时候发现没有效果/报错？到底是我的问题还是Vue官方的问题还是项目框架的问题？
>
> 经过后面和云翔一起探讨，我们发现其实Vue-router在对于懒加载的处理上，其接受的是一个Function，内返回一个Promise对象。对于经过Webpack处理后的模块，其本身就是一个Promise，直接按照官方给的例子自然是无法正常运作。我们在其外面包裹了一层Function后异步加载才算是正常运作。
>
> 但是方案并不完美，因为我们仅能按`模块`来异步加载，这已经是三级依赖在目前Webpack极致下的极限，除非我们可以去改动Webpack的源码或者自己创建一个loader之类的东西专门处理这种情况。

④封闭

> 源码不暴露，开发者之间交流困难，这样容易造成代码体积变大，同样功能的实现方式不同。
>
> 同样代码的事先方式不同，如果需求变更，那么三个开发者可能都需要去修改自己的代码。实际上这种代码仅需一个人维护一份即可，这也是同事之间Review代码的重要性。

⑤低效

> Npm依赖的本意是提供一个可靠/稳定的版本，本身功能并非迭代代码。
>
> 而Git被发明的初衷是代码版本管理，更倾向于迭代。
>
> 通过Npm依赖，我们每次更新代码都需要漫长的遍历所有的模块（包括第三方稳定依赖），也就是说从寻径来说已经慢了一大截。

### 项目架构改进想法：gitSubmodule

![image-20181010125153863](/Users/meteor/Pictures/1539147089674.jpg)

> gitSubmodule主要的作用就是一种权限管理：比如说一个父模块里面包含了很多子模块
>
> 1.对于这些子模块，父模块本身可以本地修改子模块查看效果，但是无法提交对子模块进行提交。
>
> 2.这些子模块需要有其权限的开发者才能够提交。
>
> 3.父模块可以更新子模块拉取最新的代码。

#### 工作原理：

**代码仓库：**Gogs

**自动构建：**Drone

**流程：**每个开发者都会拥有一个类似于`三级依赖架构`总库代码仓库的只读权限，这就是项目开发的主目录。主目录下面包含N个子模块，开发者需要查看的时候可在总库"修改"子模块的内容方便调试但无法影响到子模块。更新子模块代码也无需Npm参与。CI账号定期在总库拉取最新的子模块代码并build一下即可放入我们的服务器。

#### 架构优点：

①调试简单，哪里出现问题直接修改代码即可看到结果。

②层级明显，清晰。

③高效。无需Npm参与，直接Git拉取代码即可看到最新功能。

④污染小。无论是公共库/模块/总库，均可独立开发互不影响，又可清晰的看到其它开发者加入了什么内容。

⑤简单，基本的Vue CLI内的Webpack配置即可满足项目的所有需求。严格遵循官方的开发规范，所有文档均可简单应用。

#### 架构缺点：

相对于三级依赖架构，对源码无任何保护性。